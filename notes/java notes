java is platform independent and jvm (java virtual machine is platform dependent)
a = 10 a is ref var in stack and 10 is object in heap
java runs on jvm we only need jre and jvm to run java on other system

*********** String[] args means all the values you are passing in cli along with runtime
java demo "" "" ""
# JDK = Java development kit
============================
it includes jre,javac,archiever - jar, docs gen -javadocs , interpreter

# JRE = java runtime environment
================================
 
# JVM = java virtual machine
# JDK has jre and jvm
# JVM ha libraries and jvm

`*******` Our code is converted to byte code (filename.class) and this code is run by

Integer vs int => Integer is a wrapper class and int is primitive data type

| Data Type | Size    | Default Value | Description                          | Example             |
| --------- | ------- | ------------- | ------------------------------------ | ------------------- |
| `byte`    | 1 byte  | `0`           | Small integers (-128 to 127)         | `byte a = 100;`     |
| `short`   | 2 bytes | `0`           | Larger than byte (-32,768 to 32,767) | `short b = 10000;`  |
| `int`     | 4 bytes | `0`           | Default integer type                 | `int c = 50000;`    |
| `long`    | 8 bytes | `0L`          | Very large integers                  | `long d = 100000L;` |
| `float`   | 4 bytes | `0.0f`        | Decimal numbers with less precision  | `float e = 5.5f;`   |
| `double`  | 8 bytes | `0.0d`        | Decimal numbers with high precision  | `double f = 10.5;`  |
| `char`    | 2 bytes | `'\u0000'`    | Single 16-bit Unicode character      | `char g = 'A';`     |
| `boolean` | \~1 bit | `false`       | True or false                        | `boolean h = true;` |

binary format => 0b101 means 5
also 10_00_000 is valid just not to get confused

we can convert byte to int implicitly but not int to byte we have to write
byte a = (int) 500; here 500 % 256 will happen because 500 % length_of_range_of_byte is there

# Type Conversion (Automatic / Implicit)

Allowed conversions include:
byte â†’ short â†’ int â†’ long â†’ float â†’ double

# Type Casting (Manual / Explicit)




we have two types of memeory => heap and stack

`*******` `every method has a stack and every variable in a method is called local var and stored in a stack and all the variable present inside the class and outside the method are called instance var they are stored in a heap and object are just ref variable, ref var are present in stack and object is created in heap`

| Feature         | Local Variable                                 | Instance Variable                       |
| --------------- | ---------------------------------------------- | --------------------------------------- |
| Declared in     | Inside a method/constructor/block              | Inside a class, outside methods         |
| Scope           | Only within that method/block                  | Entire class via object reference       |
| Lifetime        | Created when method is called; destroyed after | Lives as long as the object lives       |
| Stored in       | Stack                                          | Heap (part of object)                   |
| Access modifier | Cannot have (private, public, etc.)            | Can have access modifiers               |
| Default value   | No default value; must be initialized          | Has default (null, 0, false) if not set |



`*******` in jvm we have heap memeory, inside it we have string constant pool 
IT WILL FIND IF STRING VALUE IS PRESENT IF YES THEN THEN ASSIGN THE ADDRESS AND ARE IMMUTABLE 
everytime new string is created when append
i.e why string builder was there
i.e String s1 = "J" and String s2 = "j" and s1 == s2

# string str = new String("HELLO");
# string str1 = "HELLO";

here str is stored in heap memory and str1 is stored in string constant pool
so str != str1


`Increasing capacity rule for SB => new capacity = (old capacity * 2) + 2`
`******************************` 


# STATIC
# ======

`static keyword means variables belongs to class rather than object and for each object value  is same`
`using static { name = "value"} we can initialised value for var  `

first class is loaded then objects are instantiated  
to directly load class we can use Class.forName("class_name")

to have utility methods we use static with them not do again create objects
to have classes having relation wiht outer classes we use static and for normal reason also

to create non static sub class
==============================
# A obj = new A(); 
# A.C obj1 = obj.new C()

to create static sub class
==============================
******** A.C obj2 = new A.C()

in java if child class constructor is called then super class is already present and called parent class default constructor

`********`   if we want to call paramterised constructor of parent we have to pass values in super keyword

## the super keyoword is present already in it and is hidden 
# every super class in java extends Object class by default

`********` join method will make sure till the thread is not stopped it wont execute
# this() it will call the constructor of the same class

********
========
class Child extends  Parent{
    Child(){
        this(1);
        System.out.println("This is child"); 
    }

    Child(int a){
        this(1,2);
        System.out.println("This is child 1 paramter"); 
    }

    Child(int a,int b){
        System.out.println("This is child 2 parameter"); 
    }
}




# object that does not have any name are called anonymous object
like => new Class()

******** =>  typically used for one-time use where you don't need to reuse the object later.  

by default java.lang is there imported so sout is working





# MODIFIERS
******** ==

`those who will give error`
`src/`
`â”œâ”€â”€ pkg1/`
`â”‚   â”œâ”€â”€ Base.java => `
`â”‚   â”œâ”€â”€ SubSamePackage.java => pvt`
`â”‚   â””â”€â”€ NonSubSamePackage.java => pvt`
`â”œâ”€â”€ pkg2/`
`â”‚   â”œâ”€â”€ SubDifferentPackage.java => pvt,def`
`â”‚   â””â”€â”€ NonSubDifferentPackage.java => pvt,def,prot`


# Polymorphism 
==============  

compile time => overloading
runtime => overriding

# final

`in var => const var`
`in class => to stop inheritance`
`in method => if you dont want to override any method`


# int a = 10;     Integer b = a;// Auto-boxing (int â†’ Integer)      int c = b; / Unboxing (Integer â†’ int)


********** `we cannot create object of abstract class`

we defined abstract methods and initialised them in sub classes and abstract class can have both abstract and nonabstract methods but abstract method should have abstract class

# for extending either we need all function from abstract class or just abstract keyword in sub class generally non abstract class are called concrete class

*** `we cannot create oject of abstract class it is called by obj  of non abstract sub class` 





# Inner class
=============

********** when we create class after object
A obj = new A(){
    public void hello(){

    }
}

file name will be A$1.class






| ðŸ”¹ **Type**               | ðŸ”¹ **Where Itâ€™s Created**              | ðŸ”¹ **Purpose / Use**                                                                                                                                                                                            |
| ------------------------- | -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Member Inner Class**    | Inside a class (non-static)            | - Acts as a helper class tightly bound to the outer class. <br> - Can access all outer class members, even `private`. <br> - Useful when the inner class is not meaningful outside the outer class.             |
| **Static Nested Class**   | Inside a class with `static` modifier  | - Groups related static classes. <br> - Does **not** need outer class instance. <br> - Can only access static members of outer class. <br> - Good for utility/helper classes that don't depend on object state. |
| **Local Inner Class**     | Inside a method, constructor, or block | - Exists only within that method/block. <br> - Used for temporary, short-lived functionality. <br> - Keeps code localized and clean.                                                                            |
| **Anonymous Inner Class** | Inside a method or passed as argument  | - Used for **one-time** implementation of an interface or abstract class. <br> - Common in event handling and callbacks. <br> - No class name, defined and instantiated together.                               |
